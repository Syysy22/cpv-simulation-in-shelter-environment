import os, pickle, random, math, numpy as np, time
from collections import defaultdict


# ---------- Paths ----------
BASE_DIR = os.path.dirname(__file__)
DATA_DIR = os.path.abspath(os.path.join(BASE_DIR, "..", "data"))
os.makedirs(DATA_DIR, exist_ok=True)

FULL_STATE_PATH = os.path.join(DATA_DIR, "full_simulation.pkl")  # baseline snapshot (generated by movement_simulation.py)
SAVE_PATH       = os.path.join(DATA_DIR, "cpv_vax.pkl")          # single output for vaccination scenarios

# ---------- Load baseline simulation state ----------
if not os.path.exists(FULL_STATE_PATH):
    raise FileNotFoundError(
        f"{FULL_STATE_PATH} not found.\n"
        "Please run `movement_simulation.py` first to generate data/full_simulation.pkl."
    )

with open(FULL_STATE_PATH, "rb") as f:
    saved = pickle.load(f)

G = saved["graph"]
coord_to_index = saved["coord_to_index"]
index_to_coord = {v: k for k, v in coord_to_index.items()}
occupancy = saved["occupancy"]
round_start_times = sorted(saved["round_start_times"])
original_dog_health = saved["dog_health"]
original_staff_health = saved["staff_health"]
original_node_contamination = saved["node_contamination"]

# -------------------- constants keep fixed --------------------------
ROUNDS_PER_DAY = 4
CLEAN_DAYS = 7                         # environment deep clean interval (days)
CLEAN_ROUNDS = CLEAN_DAYS * ROUNDS_PER_DAY
STAFF_CLEAR_ROUNDS = 4                 # staff decontamination cadence (rounds)

# Transmission rates for this regime (edit as needed)
P_DIRECT = 0.0003
P_ENV    = 0.0001
# -------------------- vaccination parameters -------------------
VACCINE_COVERAGES = [0, 0.50, 0.75]       # scenarios to run
VACCINE_EFFECTIVENESS = 0.85           # <— effectiveness (VE)
PROTECTION_DELAY_DAYS = 3              # <— onset of protection after vaccination
CAMPAIGN_PERIOD_DAYS = 30              # rolling campaign period
CAMPAIGN_START_DAY = 0                # vaccinate on day 0, 30, 60...

# -------------------- housekeeping --------------------------------------
all_times = sorted(occupancy.keys())
max_day = all_times[-1] // 86400
BASE_SEED = 12345
STRATEGY_BASE = f"env{CLEAN_DAYS}d_staff{STAFF_CLEAR_ROUNDS}r"

def run_strategy(vax_coverage: float):
    """Run 50 replicates for a given vaccination coverage and return summary series."""
    daily_total_infected_matrix = np.zeros((50, max_day + 1))
    daily_infectious_matrix     = np.zeros((50, max_day + 1))
    daily_contaminated_matrix   = np.zeros((50, max_day + 1))
    total_dogs_simulated        = np.zeros(50)
    per_round_infected_staff_runs = []

    start_time = time.time()
    for sim in range(50):
        random.seed(BASE_SEED + sim)
        np.random.seed(BASE_SEED + sim)

        dog_health         = original_dog_health.copy()
        staff_health       = original_staff_health.copy()
        node_contamination = original_node_contamination.copy()

        # infection & vaccination tracking
        exposure_time = {}                 # dog_id -> time exposed
        detected_and_isolated = set()
        infectious_dogs = set()
        recovered_dogs = set()

        vaccinated_dogs = set()            # received a dose (avoid re-vaccinating)
        pending_immunity = {}              # dog_id -> unix_time when protection starts
        immune_dogs = set()                # fully protected dogs

        # metrics
        daily_total_infected_dogs = defaultdict(set)
        daily_currently_infectious_dogs = defaultdict(set)
        daily_contaminated_nodes = defaultdict(set)
        dog_replaced = defaultdict(int)
        per_round_staff_infected = np.zeros(len(round_start_times), dtype=int)
        current_round_infected_staff = set()
        vaccinated_on_day = set()          # ensure one vaccination action per campaign day

        # initialise exposure times for initially exposed dogs
        for d in dog_health:
            if dog_health[d] == 1:
                exposure_time[d] = 0

        # main timeline
        for t in all_times:
            # round boundaries: staff clear-outs and environment cleans
            if t in round_start_times:
                round_idx = round_start_times.index(t)
                if round_idx > 0:
                    per_round_staff_infected[round_idx - 1] = len(current_round_infected_staff)
                    current_round_infected_staff.clear()

                if (round_idx % STAFF_CLEAR_ROUNDS) == 0:
                    staff_health = {i: 0 for i in staff_health}

                if round_idx > 0 and (round_idx % CLEAN_ROUNDS) == 0:
                    node_contamination = {i: 0 for i in node_contamination}

            day_index = t // 86400

            # rolling vaccination campaign: first day of each 30-day cycle
            if (day_index % CAMPAIGN_PERIOD_DAYS) == CAMPAIGN_START_DAY and day_index not in vaccinated_on_day:
                present_dogs = list(dog_health.keys())
                covered = [d for d in present_dogs if d in vaccinated_dogs]  # any dog that has received a dose
                N = len(present_dogs)
                target_n = int(np.ceil(vax_coverage * N))    # aim for >= target coverage
                current_n = len(covered)
                shortfall = max(0, target_n - current_n)

                # eligible = all dogs that have not yet been vaccinated in this simulation
                eligible = [d for d in present_dogs if d not in vaccinated_dogs]

                if shortfall > 0 and eligible:
                    n_to_vax = min(shortfall, len(eligible))
                    chosen = np.random.choice(eligible, size=n_to_vax, replace=False)
                    for d in chosen:
                        vaccinated_dogs.add(d)
                        pending_immunity[d] = t + PROTECTION_DELAY_DAYS * 86400

                vaccinated_on_day.add(day_index)

            # activate protection when delay elapsed
            if pending_immunity:
                to_activate = [d for d, t0 in list(pending_immunity.items()) if t >= t0]
                for d in to_activate:
                    if random.random() < VACCINE_EFFECTIVENESS:
                        immune_dogs.add(d)
                    pending_immunity.pop(d, None)

            # incubation progression
            for d in sorted(exposure_time.keys()):
                if d not in infectious_dogs:
                    incubation_days = (t - exposure_time[d]) / 86400
                    if incubation_days >= random.randint(1, 5):
                        infectious_dogs.add(d)

            for node in sorted(occupancy[t].keys()):
                occupants = occupancy[t][node]      

                # Consider only active dogs (not isolated)
                dogs_here  = sorted({id for kind, id in occupants
                                    if kind == "dog" and id not in detected_and_isolated})
                staff_here = sorted({id for kind, id in occupants if kind == "staff"})
    
                # --- Direct contact: dog↔staff and dog↔dog ---
                for d in dogs_here:
                    if d in infectious_dogs:
                        for s in staff_here:
                            if staff_health[s] == 0 and random.random() < P_DIRECT:
                                staff_health[s] = 1

                        for d2 in dogs_here:
                            if d != d2 and dog_health[d2] == 0 and (d2 not in immune_dogs) and random.random() < P_DIRECT:
                                    dog_health[d2] = 1
                                    exposure_time[d2] = t
                    
                    elif dog_health[d] == 0 and (d not in immune_dogs):
                        for s in staff_here:
                            if staff_health[s] == 1 and random.random() < P_DIRECT:
                                dog_health[d] = 1
                                exposure_time[d] = t

                # --- Environment transmission to unexposed ---
                for d in dogs_here:
                    if dog_health[d] == 0 and (d not in immune_dogs) and node_contamination.get(node, 0) == 1 and random.random() < P_ENV:
                        dog_health[d] = 1
                        exposure_time[d] = t

                for s in staff_here:
                    if staff_health[s] == 0 and node_contamination.get(node, 0) == 1 and random.random() < P_ENV:
                        staff_health[s] = 1

                # --- Environment contamination from infected ---
                if any(d in infectious_dogs for d in dogs_here) or any(staff_health.get(s, 0) == 1 for s in staff_here):
                    if random.random() < P_ENV:
                        node_contamination[node] = 1

                # Record node contamination for the day
                if node_contamination.get(node, 0) == 1:
                    daily_contaminated_nodes[day_index].add(node)

            # detection, recovery, replacement
            for d in sorted(infectious_dogs):
                days_exposed = (t - exposure_time[d]) / 86400

                if d not in detected_and_isolated and days_exposed >= 14:
                    p_detect = 1 / (1 + math.exp(-0.6 * (days_exposed - 17)))
                    if random.random() < p_detect:
                        detected_and_isolated.add(d)

                if days_exposed >= 20:
                    p_recover = 1 / (1 + math.exp(-0.3 * (days_exposed - 27)))
                    if random.random() < p_recover:
                        dog_health[d] = 0
                        # reset to "new dog" (remove any vaccine status)
                        exposure_time.pop(d, None)
                        infectious_dogs.discard(d)
                        detected_and_isolated.discard(d)
                        pending_immunity.pop(d, None)
                        immune_dogs.discard(d)
                        vaccinated_dogs.discard(d)
                        dog_replaced[d] += 1

            # metrics at this timestamp
            for d in dog_health:
                if dog_health[d] == 1:
                    daily_total_infected_dogs[day_index].add(d)
            for d in infectious_dogs:
                if d not in detected_and_isolated:
                    daily_currently_infectious_dogs[day_index].add(d)
            current_round_infected_staff.update([i for i, v in staff_health.items() if v == 1])

        # close out final round
        per_round_staff_infected[len(round_start_times) - 1] = len(current_round_infected_staff)

        # aggregate to matrices
        for day in range(max_day + 1):
            daily_total_infected_matrix[sim, day] = len(daily_total_infected_dogs.get(day, []))
            daily_infectious_matrix[sim, day]     = len(daily_currently_infectious_dogs.get(day, []))
            daily_contaminated_matrix[sim, day]   = len(daily_contaminated_nodes.get(day, []))

        unreplaced = set(dog_health) - set(dog_replaced)
        total_dogs_simulated[sim] = sum(dog_replaced[d] + 1 for d in dog_replaced) + len(unreplaced)
        per_round_infected_staff_runs.append(per_round_staff_infected)

        print(f"[cov={int(vax_coverage*100)}%] Simulation {sim+1} finished.")

    print(f"[cov={int(vax_coverage*100)}%] All 50 simulations completed in {time.time()-start_time:.2f} s.")

    # means across replicates
    avg_contaminated = np.round(daily_contaminated_matrix.mean(axis=0)).astype(int)
    avg_total_inf    = np.round(daily_total_infected_matrix.mean(axis=0)).astype(int)
    avg_infectious   = np.round(daily_infectious_matrix.mean(axis=0)).astype(int)
    avg_total_dogs   = int(round(total_dogs_simulated.mean()))
    infected_staff_runs_matrix = np.vstack(per_round_infected_staff_runs)
    avg_staff_per_round = infected_staff_runs_matrix.mean(axis=0)

    # package results
    label = f"{STRATEGY_BASE}_vax{int(vax_coverage*100)}"
    results_chunk = {
        "label": label,
        "clean_days": CLEAN_DAYS,
        "clean_rounds": CLEAN_ROUNDS,
        "staff_clear_rounds": STAFF_CLEAR_ROUNDS,
        "rates": {"direct": P_DIRECT, "env": P_ENV},
        # vaccination metadata
        "vax_coverage": vax_coverage,
        "vax_effectiveness": VACCINE_EFFECTIVENESS,     # 0.85
        "vax_delay_days": PROTECTION_DELAY_DAYS,        # 3
        "vax_period_days": CAMPAIGN_PERIOD_DAYS,
        "vax_start_day": CAMPAIGN_START_DAY,
        # horizons
        "max_day": int(max_day),
        "n_rounds": len(round_start_times),
        # series
        "avg_total_infected_per_day": avg_total_inf,
        "avg_infectious_per_day":     avg_infectious,
        "avg_contaminated_per_day":   avg_contaminated,
        "avg_staff_per_round":        avg_staff_per_round,
        "avg_total_dogs":             avg_total_dogs,
    }
    return label, results_chunk

# ---------- run and save both strategies ----------
store = {}
for cov in VACCINE_COVERAGES:
    label, chunk = run_strategy(cov)
    store[label] = chunk

with open(SAVE_PATH, "wb") as f:
    pickle.dump(store, f)

print(f"Saved vaccination scenarios to {SAVE_PATH}:")
for cov in VACCINE_COVERAGES:
    print(f"  - {STRATEGY_BASE}_vax{int(cov*100)}")
